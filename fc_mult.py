import itertools
from collections import defaultdict

""" Tuple Operations """

def remove_first(t,y):
    """ Remove the first occurrence of t from a tuple y.
    
    EXAMPLE:
        sage: remove_first(3,(1,2,3,4,3,2)) 
        sage: (1,2,4,3,2)
    """

    a = y.index(t)
    return y[:a]+y[a+1:]

def neighbors_before(s,y):
    """ Find the indices neighbors of s before its first appearance in y. Stop
    if 2 neighbors are found.

    Note: If the resulting list is empty, sy < y. If two neighbors are found,
    sy is still fully-commutative. 
 
    EXAMPLE:
        sage: count_neighbors(3,(2,1,4,2,3))
        sage:   
    """

    i = 0
    l = []
    while len(l)<2 and i<y.index(s):
            if y[i] == s+1 or y[i] == s-1:
                l = l+[i]
            else:
                l = l
            i = i+1
    return l

def first_12(y):
    """ Find the index of the first occurence of 1 or 2 in y. Return -1 if
    there's no 1 or 2 in y.
    
    EXAMPLE:
        sage: first_12((1,3,4,2))
        sage: 0

        sage: first_12((3,2,4,1))
        sage: 1

        sage: first_12((3,4))
        sage: -1 
    """
    i = 0
    index = -1
    while i < len(y):
        if y[i] > 2:
            i = i + 1
        else: 
            index = i
            break
    return index

def first_neighbor(s,y):
    """ Find the index of the leftmost neighbor of s in y. 

    Note: We will only call this function when we know there is such a
    neighbor.

    EXAMPLE:
        sage: first_neighbor(2,(5,3,1,4))
        sage: 1

        sage: first_neighbor(2,(5,4,1,2))
        sage: 2
    """
    i = 0
    while i < len(y):
        if y[i] == s-1 or y[i] == s+1:
            return i
        else: 
            i = i+1

def before_12(y):
    """
    
    EXAMPLE: 
        sage: before_12((3,4,5))
        sage: (3,4,5)

        sage: before_12((3,4,1,2,5))
        sage: (3,4)

        sage: before_12((3,4,2,5))
        sage: (3,4)
    """

    if first_1_or_2(y) == -1:
        return y
    else:
        return y[:first_1_or_2(y)]

def after_12(y):
    """
    
    EXAMPLE: 
        sage: after_12((3,4,5))
        sage: ()

        sage: after_12((3,4,1,2,5))
        sage: (1,2,5)

        sage: after_12((3,4,2,5))
        sage: (2,5)
    """
    if first_1_or_2(y) == -1:
        return tuple()
    else: 
        return y[first_1_or_2(y):]

def my_index(s,y):
    """ Return the index of s in y if s is in y; otherwise return -1. 
    
    EXAMPLE:
        sage: my_index(1,(2,1,3))
        sage: 1

        sage: my_index(1,(2,3,4))
        sage: -1
    """
    try: 
        return y.index(s)
    except ValueError:
        return -1

def onetwo_on_left(y):
    """ Return the coset decomposition y_1 * y_2 of y, where y_1 is in the
    parabolic subgroup generated by 1 and 2 and neither 1 or 2 reduces y_2.  
    
    EXAMPLE:
        sage: onetwo_on_left((1,2,3)) 
        sage: ((1,2), (3,))
        
        sage: onetwo_on_left((1,2,3,1))
        sage: ((1,2,1,),(3,))

        sage: onetwo_on_left((1,2,3,2,1))
        sage: ((1,2,1),(3,1))
    """

    parabolic = tuple()
    minimal = y

    if first_12(y) > -1:
        s = y[first_12(y)]
        i = 1
        while i < 5 and my_index(s,minimal) > -1 and neighbors_before(s, minimal) == []:
            s = minimal[first_1_or_2(minimal)]
            parabolic = parabolic + (s,)
            minimal = remove_first(s,minimal)    
            i = i + 1
            s = 3 - s
    return parabolic, minimal 

def my_append(l,x):
    if x == tuple():
        return l
    else: 
        return l + [x]

def left_justify(y):
    """ Return the segments of the left justified word of y.

    EXAMPLE:
        sage: left_justify((1,2,3,1,4,2,1,5))
        sage: ((1,2,1),(3,4),(2,1),(5,) )

        sage: left_justify((3,2,1,3,2,5,1))
        sage: ((3),(2,1),(3,),(2,1),(5,))
    """
    l = []
    remain = y
    while remain != tuple():
        x = onetwo_on_left(remain)[0]
        y = onetwo_on_left(remain)[1]
        ll = my_append(l,x)
        l = my_append(ll,before_12(y))
        remain = after_12(y) 
    return l

def right_justify(y):
    """ Return the segments of the right justified word of y.
    
    EXAMPLE:
        sage: right_justify((1,2,3,1,4,2,1,5))
        sage: ((1,2),(3,4,5),(1,2,1))
    
    """
    z = y[::-1]
    l = left_justify(z)
    ll = [i[::-1] for i in l]
    return ll[::-1]

# variables for the six types of 12-chuncks in a right justified word. They
# represent, in order: c1c2-1, c1c2c1-c1, c2c1c2-c2, c1c2c1c2-2c1c2,
# c2c1c2-2c2, c2c1c2c1-2c2c1
var('A')
var('B')
var('C')
var('D')
var('E')
var('F')


def canonical_factors(y):
    l = right_justify(y)
    factors = []
    for i in range(len(l)):
        seg = l[i]
        if seg[0] == 1 or seg[0] == 2:
            if seg == (1,) or seg == (2,) or seg == (2,1):
                factors = factors + [i for i in seg]
            elif seg == (1,2):
                if i < len(l) - 2 and l[i+2][0] == 1:
                    factors = factors + [A]
                else:
                    factors = factors + [1,2]
            elif seg == (1,2,1):
                factors = factors + [B]
            elif seg == (2,1,2):
                if i < len(l) - 3 and l[i+2][0] == 1:
                    factors = factors + [E]
                else:
                    factors = factors + [C]
            elif seg == (1,2,1,2):
                factors = factors + [D]
            elif seg == (2,1,2,1):
                factors = factors + [F]
        else:
            factors = factors + [j for j in seg]
    return factors





def s_times_w(s,y):
    if my_index(s,y) == -1:                      # if s does not appear in y
        return {(s,)+y: 1}
    elif neighbors_before(s,y) == []:           # this is equivalent to sy<y 
        return {y: v + v**(-1)}
    elif len(neighbors_before(s,y)) == 2:        # this means sy is still f.c.
        return {(s,) + y: 1}
    else:
        d = defaultdict()
        left = [s]
        right = [y]
        neighbor_index = neighbors_before(s,y)[0]
        while left != []: 
            if s[-1] > 3:
                factors_of_y = canonical_factors(y)
                left = factors_of_y[:neighbor_index] 
                d[factors_of_y[neighbor_index+1:]] = 1
        return d
